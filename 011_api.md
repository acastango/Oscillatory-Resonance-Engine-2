# BRIEFING: EntityAPI

## Component ID: ORE2-011
## Priority: Medium-High (Production interface)
## Estimated complexity: Medium

---

## What This Is

REST and WebSocket API for interacting with ORE entities. This is how external systems (web apps, mobile apps, other services) communicate with ORE without importing Python directly.

- **REST**: CRUD operations, conversation turns, state queries
- **WebSocket**: Real-time coherence streaming, live cognitive state

---

## Why It Matters

**X6 (Enterprise):** "Production systems don't import Python modules. They call APIs. Without this, ORE is a research toy."

**I1 (Systems Architect):** "Separation of concerns. The entity runs in one process, clients connect over HTTP/WS. Scales better, deploys cleaner."

**S2 (Distributed Systems):** "WebSocket for the dashboard - you want to see coherence updating in real-time, not poll every second."

---

## The Core Insight

Two interaction patterns:

1. **Request-Response** (REST): Create entity, process input, get state, save/load
2. **Streaming** (WebSocket): Subscribe to cognitive state, get updates as they happen

Both share authentication - entities have identity, clients need permission.

```
┌─────────────────────────────────────────────────────────┐
│                     EntityAPI                            │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  REST Endpoints              WebSocket Channels          │
│  ───────────────             ──────────────────          │
│  POST /entities              ws://host/ws/{entity_id}    │
│  GET  /entities/{id}           → cognitive_state         │
│  POST /entities/{id}/turn      → coherence_stream        │
│  POST /entities/{id}/rest      → memory_events           │
│  GET  /entities/{id}/state     → claim_activations       │
│  POST /entities/{id}/save                                │
│  POST /entities/{id}/claims                              │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

---

## Interface Contract

```python
class EntityAPI:
    """
    HTTP/WebSocket API for ORE entities.
    
    Methods:
        # Server lifecycle
        start(host, port)
        stop()
        
        # Entity management (internal)
        register_entity(entity, entity_id) -> str
        get_entity(entity_id) -> DevelopmentalEntity
        list_entities() -> List[EntityInfo]
        
        # Auth
        create_api_key(entity_id, permissions) -> str
        validate_api_key(key) -> Optional[APIKeyInfo]
"""

# REST Response Models
@dataclass
class EntityInfo:
    entity_id: str
    name: str
    genesis_hash: str
    stage: str
    age: float
    created_at: str

@dataclass
class StateResponse:
    entity_id: str
    timestamp: str
    cognitive_state: CognitiveState
    substrate_summary: dict
    memory_summary: dict
    
@dataclass
class TurnResponse:
    entity_id: str
    user_input: str
    response: str
    process_result: dict
    generation_result: dict
    cognitive_state: CognitiveState

# WebSocket Message Types
@dataclass
class WSMessage:
    type: str  # "cognitive_state", "coherence", "memory_event", "claim_activation"
    timestamp: str
    data: dict
```

---

## REST Endpoints

### `POST /entities` - Create Entity

```python
# Request
{
    "name": "Aria",
    "config": {  # Optional
        "fast_oscillators": 100,
        "slow_oscillators": 50
    }
}

# Response 201
{
    "entity_id": "ent_a1b2c3d4",
    "name": "Aria",
    "genesis_hash": "abc123...",
    "stage": "genesis",
    "api_key": "ore_key_xyz..."  # For subsequent requests
}
```

### `GET /entities/{id}` - Get Entity Info

```python
# Response 200
{
    "entity_id": "ent_a1b2c3d4",
    "name": "Aria",
    "genesis_hash": "abc123...",
    "stage": "babbling",
    "age": 1523.4,
    "created_at": "2025-01-30T10:00:00Z",
    "experience_count": 47,
    "memory_nodes": 52,
    "ci": 0.342
}
```

### `POST /entities/{id}/turn` - Conversation Turn

```python
# Request
{
    "input": "What do you think about consciousness?",
    "context": "Optional additional context"  # Optional
}

# Response 200
{
    "response": "Consciousness is fascinating...",
    "cognitive_state": {
        "coherence": 0.67,
        "valence": -0.12,
        "ci": 0.35,
        "active_claims": ["I examine problems systematically"]
    },
    "processing": {
        "significance": 0.72,
        "memories_triggered": 3,
        "coherence_change": 0.05
    }
}
```

### `GET /entities/{id}/state` - Full State

```python
# Response 200
{
    "entity_id": "ent_a1b2c3d4",
    "timestamp": "2025-01-30T12:34:56Z",
    "cognitive_state": {
        "coherence": 0.67,
        "cross_scale_coherence": 0.54,
        "loop_coherence": 0.48,
        "valence": -0.12,
        "energy": 0.89,
        "arousal": 0.45,
        "ci": 0.35
    },
    "substrate": {
        "fast_active": 12,
        "fast_total": 100,
        "slow_active": 8,
        "slow_total": 50,
        "time": 1523.4
    },
    "memory": {
        "total_nodes": 52,
        "depth": 4,
        "branches": {
            "self": 5,
            "relations": 3,
            "insights": 12,
            "experiences": 32
        },
        "grain_boundaries": 2
    },
    "development": {
        "stage": "babbling",
        "stage_progress": 0.34,
        "oscillators": 45,
        "milestones": 3
    },
    "claims": {
        "total": 8,
        "active": ["claim_001", "claim_003"],
        "consistency": 0.78
    }
}
```

### `POST /entities/{id}/rest` - Trigger Rest

```python
# Request
{
    "duration": 10.0  # Optional, default 10.0
}

# Response 200
{
    "duration": 10.0,
    "consolidation": {
        "consolidated": 5,
        "tensions_resolved": 1,
        "remaining_tensions": 1
    },
    "ci_after": 0.38
}
```

### `POST /entities/{id}/claims` - Add/Activate Claims

```python
# Request - Add claim
{
    "action": "add",
    "content": "I value clear communication",
    "strength": 0.8,
    "scope": "behavior"
}

# Request - Activate role
{
    "action": "activate_role",
    "role": "analyst"
}

# Response 200
{
    "claims_affected": ["claim_009", "claim_010", "claim_011"],
    "active_claims": 5,
    "consistency": 0.82
}
```

### `POST /entities/{id}/save` - Save Entity

```python
# Request
{
    "path": "/data/entities/aria.ore2",  # Optional
    "checkpoint": true  # Optional - create checkpoint instead
}

# Response 200
{
    "path": "/data/entities/aria.ore2",
    "genesis_hash": "abc123...",
    "merkle_root": "def456...",
    "state_hash": "ghi789...",
    "size_bytes": 145632,
    "verified": true
}
```

### `POST /entities/load` - Load Entity

```python
# Request
{
    "path": "/data/entities/aria.ore2"
}

# Response 201
{
    "entity_id": "ent_e5f6g7h8",  # New ID for this session
    "name": "Aria",
    "genesis_hash": "abc123...",  # Same as saved
    "verified": true,
    "api_key": "ore_key_abc..."
}
```

---

## WebSocket Protocol

### Connection

```
ws://host:port/ws/{entity_id}?api_key={key}
```

### Subscribe to Channels

```python
# Client sends
{
    "type": "subscribe",
    "channels": ["cognitive_state", "coherence", "memory_events"]
}

# Server responds
{
    "type": "subscribed",
    "channels": ["cognitive_state", "coherence", "memory_events"]
}
```

### Channel Messages

**cognitive_state** (every N ticks or on significant change):
```python
{
    "type": "cognitive_state",
    "timestamp": "2025-01-30T12:34:56.789Z",
    "data": {
        "coherence": 0.67,
        "valence": -0.12,
        "ci": 0.35,
        "stage": "babbling"
    }
}
```

**coherence** (high frequency, every tick):
```python
{
    "type": "coherence",
    "timestamp": "2025-01-30T12:34:56.789Z",
    "data": {
        "global": 0.67,
        "fast": 0.72,
        "slow": 0.61,
        "cross_scale": 0.54,
        "loop": 0.48
    }
}
```

**memory_events** (on memory changes):
```python
{
    "type": "memory_event",
    "timestamp": "2025-01-30T12:34:56.789Z",
    "data": {
        "event": "node_added",  # or "consolidated", "tension_detected"
        "branch": "experiences",
        "node_id": "node_20250130...",
        "coherence_at_creation": 0.67
    }
}
```

**claim_activations** (on claim changes):
```python
{
    "type": "claim_activation",
    "timestamp": "2025-01-30T12:34:56.789Z",
    "data": {
        "event": "activated",  # or "deactivated", "added"
        "claim_id": "claim_009",
        "content": "I examine problems systematically",
        "strength": 0.8
    }
}
```

---

## Implementation Specification

### Server Setup (FastAPI)

```python
from fastapi import FastAPI, WebSocket, HTTPException, Depends
from fastapi.security import APIKeyHeader
import asyncio

class EntityAPI:
    def __init__(self, config: Optional[APIConfig] = None):
        self.config = config or APIConfig()
        self.app = FastAPI(title="ORE 2.0 API")
        self.entities: Dict[str, DevelopmentalEntity] = {}
        self.bridges: Dict[str, LLMBridge] = {}
        self.api_keys: Dict[str, APIKeyInfo] = {}
        self.ws_connections: Dict[str, List[WebSocket]] = {}
        
        self._setup_routes()
    
    def _setup_routes(self):
        """Configure all routes."""
        
        # REST routes
        self.app.post("/entities")(self.create_entity)
        self.app.get("/entities/{entity_id}")(self.get_entity_info)
        self.app.post("/entities/{entity_id}/turn")(self.conversation_turn)
        self.app.get("/entities/{entity_id}/state")(self.get_full_state)
        self.app.post("/entities/{entity_id}/rest")(self.trigger_rest)
        self.app.post("/entities/{entity_id}/claims")(self.manage_claims)
        self.app.post("/entities/{entity_id}/save")(self.save_entity)
        self.app.post("/entities/load")(self.load_entity)
        
        # WebSocket route
        self.app.websocket("/ws/{entity_id}")(self.websocket_handler)
    
    async def create_entity(self, request: CreateEntityRequest) -> EntityCreatedResponse:
        """Create new entity."""
        # Create entity
        config = EntityConfig(name=request.name)
        if request.config:
            # Apply custom config
            pass
        
        entity = DevelopmentalEntity(config)
        entity_id = f"ent_{entity.genesis_hash[:8]}"
        
        # Create bridge if LLM configured
        if self.config.llm_client:
            bridge = LLMBridge(entity, self.config.llm_client)
            self.bridges[entity_id] = bridge
        
        self.entities[entity_id] = entity
        
        # Generate API key
        api_key = self._generate_api_key(entity_id)
        
        return EntityCreatedResponse(
            entity_id=entity_id,
            name=entity.name,
            genesis_hash=entity.genesis_hash,
            stage=entity.stage.value,
            api_key=api_key,
        )
    
    async def conversation_turn(self, 
                                entity_id: str, 
                                request: TurnRequest,
                                api_key: str = Depends(api_key_header)) -> TurnResponse:
        """Process conversation turn."""
        self._validate_access(api_key, entity_id)
        
        entity = self.entities.get(entity_id)
        if not entity:
            raise HTTPException(404, "Entity not found")
        
        bridge = self.bridges.get(entity_id)
        if not bridge:
            raise HTTPException(400, "No LLM bridge configured")
        
        # Process turn
        response = bridge.conversation_turn(request.input)
        state = bridge.get_cognitive_state()
        
        # Broadcast state update to WebSocket subscribers
        await self._broadcast(entity_id, "cognitive_state", asdict(state))
        
        return TurnResponse(
            entity_id=entity_id,
            user_input=request.input,
            response=response,
            cognitive_state=state,
        )
    
    async def websocket_handler(self, websocket: WebSocket, entity_id: str):
        """Handle WebSocket connections."""
        # Validate API key from query param
        api_key = websocket.query_params.get("api_key")
        if not self._validate_access(api_key, entity_id, raise_error=False):
            await websocket.close(code=4001)
            return
        
        await websocket.accept()
        
        # Track connection
        if entity_id not in self.ws_connections:
            self.ws_connections[entity_id] = []
        self.ws_connections[entity_id].append(websocket)
        
        subscribed_channels = set()
        
        try:
            while True:
                data = await websocket.receive_json()
                
                if data["type"] == "subscribe":
                    subscribed_channels.update(data["channels"])
                    await websocket.send_json({
                        "type": "subscribed",
                        "channels": list(subscribed_channels)
                    })
                
                elif data["type"] == "unsubscribe":
                    subscribed_channels -= set(data["channels"])
        
        except Exception:
            pass
        finally:
            self.ws_connections[entity_id].remove(websocket)
    
    async def _broadcast(self, entity_id: str, channel: str, data: dict):
        """Broadcast to all WebSocket subscribers."""
        if entity_id not in self.ws_connections:
            return
        
        message = {
            "type": channel,
            "timestamp": datetime.now().isoformat(),
            "data": data
        }
        
        for ws in self.ws_connections[entity_id]:
            try:
                await ws.send_json(message)
            except:
                pass  # Connection closed
    
    def start(self, host: str = "0.0.0.0", port: int = 8000):
        """Start the API server."""
        import uvicorn
        uvicorn.run(self.app, host=host, port=port)
```

### Background Tick Loop

```python
class EntityAPI:
    # ... previous code ...
    
    async def _tick_loop(self, entity_id: str):
        """Background loop to tick entity and broadcast updates."""
        entity = self.entities.get(entity_id)
        if not entity:
            return
        
        while entity_id in self.entities:
            # Tick
            result = entity.tick()
            
            # Broadcast coherence (high frequency)
            await self._broadcast(entity_id, "coherence", {
                "global": entity.substrate.global_coherence,
                "fast": entity.substrate.fast.coherence,
                "slow": entity.substrate.slow.coherence,
                "cross_scale": entity.substrate.cross_scale_coherence,
                "loop": entity.substrate.loop_coherence,
            })
            
            # Check for significant state changes
            if self._significant_change(entity_id, result):
                state = self._get_cognitive_state(entity)
                await self._broadcast(entity_id, "cognitive_state", asdict(state))
            
            await asyncio.sleep(0.1)  # 10 Hz tick rate
```

---

## Configuration

```python
@dataclass
class APIConfig:
    # Server
    host: str = "0.0.0.0"
    port: int = 8000
    
    # Authentication
    require_api_key: bool = True
    api_key_prefix: str = "ore_"
    
    # Rate limiting
    rate_limit_per_minute: int = 60
    
    # WebSocket
    ws_tick_rate: float = 0.1  # Seconds between ticks
    ws_state_broadcast_interval: float = 1.0  # Seconds
    
    # LLM
    llm_client: Optional[LLMClient] = None
    
    # Storage
    checkpoint_dir: str = "./checkpoints"
```

---

## Authentication

```python
@dataclass
class APIKeyInfo:
    key: str
    entity_id: str
    permissions: List[str]  # ["read", "write", "admin"]
    created_at: str
    expires_at: Optional[str] = None

def _generate_api_key(self, entity_id: str) -> str:
    """Generate API key for entity."""
    import secrets
    key = f"{self.config.api_key_prefix}{secrets.token_urlsafe(32)}"
    
    self.api_keys[key] = APIKeyInfo(
        key=key,
        entity_id=entity_id,
        permissions=["read", "write"],
        created_at=datetime.now().isoformat(),
    )
    
    return key

def _validate_access(self, api_key: str, entity_id: str, 
                     raise_error: bool = True) -> bool:
    """Validate API key has access to entity."""
    if not self.config.require_api_key:
        return True
    
    info = self.api_keys.get(api_key)
    if not info or info.entity_id != entity_id:
        if raise_error:
            raise HTTPException(403, "Invalid API key")
        return False
    
    return True
```

---

## Success Criteria

### REST
1. All CRUD operations work
2. Conversation turns process correctly
3. Save/load with verification
4. Proper error responses

### WebSocket
1. Connection with auth works
2. Subscription/unsubscription works
3. Real-time updates stream correctly
4. Graceful disconnect handling

### Integration
1. Multiple entities simultaneously
2. Multiple WebSocket clients per entity
3. Background ticks continue during REST calls

---

## Test Cases

```python
def test_create_entity():
    """Should create entity and return API key."""
    client = TestClient(api.app)
    
    response = client.post("/entities", json={"name": "TestBot"})
    
    assert response.status_code == 201
    data = response.json()
    assert "entity_id" in data
    assert "api_key" in data
    assert data["name"] == "TestBot"

def test_conversation_turn():
    """Should process turn and return response."""
    client = TestClient(api.app)
    
    # Create entity
    create_resp = client.post("/entities", json={"name": "TestBot"})
    entity_id = create_resp.json()["entity_id"]
    api_key = create_resp.json()["api_key"]
    
    # Conversation turn
    response = client.post(
        f"/entities/{entity_id}/turn",
        json={"input": "Hello!"},
        headers={"X-API-Key": api_key}
    )
    
    assert response.status_code == 200
    data = response.json()
    assert "response" in data
    assert "cognitive_state" in data

def test_websocket_coherence_stream():
    """Should stream coherence updates."""
    client = TestClient(api.app)
    
    # Create entity
    create_resp = client.post("/entities", json={"name": "TestBot"})
    entity_id = create_resp.json()["entity_id"]
    api_key = create_resp.json()["api_key"]
    
    # Connect WebSocket
    with client.websocket_connect(
        f"/ws/{entity_id}?api_key={api_key}"
    ) as ws:
        # Subscribe
        ws.send_json({"type": "subscribe", "channels": ["coherence"]})
        response = ws.receive_json()
        assert response["type"] == "subscribed"
        
        # Should receive coherence updates
        update = ws.receive_json(timeout=2.0)
        assert update["type"] == "coherence"
        assert "global" in update["data"]

def test_unauthorized_access():
    """Should reject invalid API key."""
    client = TestClient(api.app)
    
    # Create entity
    create_resp = client.post("/entities", json={"name": "TestBot"})
    entity_id = create_resp.json()["entity_id"]
    
    # Try with wrong key
    response = client.get(
        f"/entities/{entity_id}/state",
        headers={"X-API-Key": "wrong_key"}
    )
    
    assert response.status_code == 403
```

---

## Dependencies

- `fastapi`
- `uvicorn`
- `websockets`
- All ORE2 core components
- `LLMBridge` (ORE2-010)

---

## File Location

```
ore2/
├── api/
│   ├── __init__.py
│   ├── server.py       # <-- Main API class
│   ├── routes.py       # Route handlers
│   ├── models.py       # Request/response models
│   ├── auth.py         # Authentication
│   └── websocket.py    # WebSocket handling
├── tests/
│   └── test_api.py
```

---

## Design Decisions to Preserve

1. **Entity ID includes genesis hash prefix** - Traceable to identity
2. **API key per entity** - Scoped access, not global
3. **WebSocket channels** - Subscribe only to what you need
4. **Background tick loop** - Entities live even when not queried
5. **Broadcast on significant change** - Don't spam, but don't miss important updates
6. **Save returns verification** - Client knows state is intact
